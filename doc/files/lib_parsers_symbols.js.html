<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/parsers/symbols.js - Websocket trading page UI</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../resources/img/logo.png" title="Websocket trading page UI"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ContractsParser.html">ContractsParser</a></li>
                                <li><a href="../classes/ContractsPatchedForCallput.html">ContractsPatchedForCallput</a></li>
                                <li><a href="../classes/Socket.html">Socket</a></li>
                                <li><a href="../classes/SymbolsParser.html">SymbolsParser</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/parsers/symbols.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Class for parsing Websocket response for &quot;active_symbols&quot; request
 *
 * @class SymbolsParser
 * @constructor
 * @example
 *      let parsed_data = new SymbolsParser(response.active_symbols);
 *      let opened_markets = parsed_data.getMarkets(1);
 */

import config from &#x27;../../config&#x27;;
import Immutable, {
    List, Map, fromJS
}
from &#x27;immutable&#x27;;

export default class SymbolsParser {

    /**
     * @method constructor
     * @param {Array} SYMBOLS
     */
    constructor(symbols) {
        const [tree, symbols_obj] = this._parse(symbols);
        Object.defineProperties(this, {
            _symbols: {
                get: () =&gt; symbols,
                set: () =&gt; {}
            },
            symbols: {
                get: () =&gt; symbols_obj,
                set: () =&gt; {}
            },
            tree: {
                get: () =&gt; tree,
                set: () =&gt; {}
            }
        });
    }

    /**
     * @method _parse
     * @private
     * @param {Array} SYMBOLS
     * @return {Array} tree Map(), symbols Map()
     */
    _parse(s) {
        const symbols = fromJS(s);
        let markets = Map();
        let symbols_obj = Map();
        if (List.isList(symbols)) {
            symbols.forEach((s) =&gt; {
                markets = this._addSymbolToTree(markets, s);
                symbols_obj = this._addSymbolToList(symbols_obj, s);
            });
        }
        return [markets, symbols_obj];
    }

    /**
     * @method _sortSymbolsList
     * @private
     * @param {List()} SYMBOLS
     * @return {List()} SYMBOLS
     */
    _sortSymbolsList(symbols = List()) {
        if (List.isList(symbols)) {
            symbols = symbols.sort((a, b) =&gt; {
                return config.markets_order[a.get(&#x27;submarket&#x27;)] - config.markets_order[b.get(&#x27;submarket&#x27;)]
            }).sort((a, b) =&gt; {
                if (a.get(&#x27;submarket&#x27;) === b.get(&#x27;submarket&#x27;)) {
                    if (a.get(&#x27;display_name&#x27;) &gt; b.get(&#x27;display_name&#x27;)) {
                        return 1;
                    } else {
                        return -1;
                    }
                } else {
                    return 0;
                }
            })
        }
        return symbols;
    }

    /**
     * Adds symbol to market/submarket tree.
     *
     * @method _addSymbolToTree
     * @private
     * @param {Map()} MARKETS
     * @param {Map()} SYMBOL
     * @return {Map()} matkets with symbol added    
     */
    _addSymbolToTree(markets = Map(), symbol) {
        if (Map.isMap(symbol) &amp;&amp; symbol.has(&#x27;is_trading_suspended&#x27;) &amp;&amp; symbol.has(&#x27;exchange_is_open&#x27;) &amp;&amp; symbol.get(&#x27;market&#x27;) &amp;&amp; symbol.get(&#x27;market_display_name&#x27;) &amp;&amp; symbol.get(&#x27;submarket_display_name&#x27;) &amp;&amp; symbol.get(&#x27;submarket&#x27;) &amp;&amp; symbol.get(&#x27;symbol&#x27;) &amp;&amp; symbol.get(&#x27;display_name&#x27;)) {
            const state = !symbol.get(&#x27;is_trading_suspended&#x27;) &amp;&amp; symbol.get(&#x27;exchange_is_open&#x27;);
            const list = [{
                market: symbol.get(&#x27;market&#x27;),
                name: symbol.get(&#x27;market_display_name&#x27;),
                is_sub: 0
            }, {
                market: symbol.get(&#x27;submarket&#x27;),
                name: symbol.get(&#x27;submarket_display_name&#x27;),
                is_sub: 1
            }, ];

            for (let m of list) {
                markets = markets.update(m.market, Map(m).set(&#x27;state&#x27;, 0), (s) =&gt; {
                    if (state) {
                        s = s.set(&#x27;state&#x27;, 1)
                    }
                    s = s.setIn([&#x27;symbols&#x27;, symbol.get(&#x27;symbol&#x27;)], Map({
                        symbol: symbol.get(&#x27;symbol&#x27;),
                        submarket: symbol.get(&#x27;submarket&#x27;),
                        name: symbol.get(&#x27;display_name&#x27;),
                        state: state
                    }));
                    return s;
                });
            }
        }
        return markets;
    }

    /**
     * Adds symbol symbols Map()
     *
     * @method _addSymbolToList
     * @private
     * @param {Map()} SYMBOL_OBJ
     * @param {Map()} SYMBOL
     * @return {Map()} symbols Map() with symbol added 
     */
    _addSymbolToList(symbols_obj = Map(), symbol) {
        if (Map.isMap(symbol) &amp;&amp; symbol.has(&#x27;is_trading_suspended&#x27;) &amp;&amp; symbol.has(&#x27;exchange_is_open&#x27;) &amp;&amp; symbol.get(&#x27;market&#x27;) &amp;&amp; symbol.get(&#x27;market_display_name&#x27;) &amp;&amp; symbol.get(&#x27;submarket_display_name&#x27;) &amp;&amp; symbol.get(&#x27;submarket&#x27;) &amp;&amp; symbol.get(&#x27;symbol&#x27;) &amp;&amp; symbol.get(&#x27;display_name&#x27;)) {
            const state = !symbol.get(&#x27;is_trading_suspended&#x27;) &amp;&amp; symbol.get(&#x27;exchange_is_open&#x27;);
            symbols_obj = symbols_obj.set(symbol.get(&#x27;symbol&#x27;), symbol.set(&#x27;state&#x27;, state));
        }

        return symbols_obj;
    }

    /**
     * Returns ordered markets. Markets order is taken from /config.json
     *
     * @method getMarkets
     * @param {0|1} ONLY_OPENED
     * @return {List()}
        [
            Map({
                market: &#x27;random&#x27;,
                name: &#x27;Randoms&#x27;,
                state: 1,
                is_sub: 0
            }),
            ...,
            Map({
                market: &#x27;random_index&#x27;,
                name: &#x27;Indices&#x27;,
                state: 1,
                is_sub: 1
            })
        ]
     */
    getMarkets(only_opened = 0) {
        let markets = List();
        this.tree.sort((a, b) =&gt; {
            return config.markets_order[a.get(&#x27;market&#x27;)] - config.markets_order[b.get(&#x27;market&#x27;)]
        }).forEach((a) =&gt; {
            const row = Map({
                market: a.get(&#x27;market&#x27;),
                name: a.get(&#x27;name&#x27;),
                state: a.get(&#x27;state&#x27;),
                is_sub: a.get(&#x27;is_sub&#x27;)
            });
            markets = markets.push(row);
        });

        if (only_opened) {
            markets = markets.filter(f =&gt; f.get(&#x27;state&#x27;));
        }

        return markets;
    }

    /**
     * Returns first opened market.
     *
     * @method getFirstActiveMarket
     * @return {Map} Market details    
     */
    getFirstActiveMarket(){
        const opened_markets = this.getMarkets(1);
        if(!opened_markets.isEmpty()){
            return opened_markets.get(0);
        }
        else{
            return;
        }
    }

    /**
     * Returns symbols for market.
     *
     * @method getSymbol
     * @param {String} SYMBOL
     * @return {Map} SYMBOL details     
     */
    getSymbol(symbol) {
        return this.symbols.get(symbol);
    }

    /**
     * Returns symbols for market.
     *
     * @method getSymbols
     * @param {String} MARKET
     * @return {List()}  
        [
             Map({
                 &quot;symbol&quot;: &quot;R_100&quot;,
                 &quot;name&quot;: &quot;Random 100 Index&quot;,
                 &quot;state&quot;: 1
             }),
             ....,
             Map({
                 &quot;symbol&quot;: &quot;R_25&quot;,
                 &quot;name&quot;: &quot;Random 25 Index&quot;,
                 &quot;state&quot;: 1
             })
        ]     
     */
    getSymbols(market) {
        const symbols_obj = this.tree.getIn([market, &#x27;symbols&#x27;]);
        if (symbols_obj) {
            const sorted_symbols = this._sortSymbolsList(symbols_obj.toList());
            const result_symbols = sorted_symbols.map(symbol =&gt; symbol.delete(&#x27;submarket&#x27;));
            return result_symbols;
        } else {
            return List();
        }
    }

    /**
     * Returns first active symbol for market.
     *
     * @method getFirstActiveSymbol
     * @param {String} MARKET
     * @return {Map} SYMBOL details    
     */
    getFirstActiveSymbol(market) {
        let symbols = this.getSymbols(market).filter((symbol) =&gt; symbol.get(&#x27;state&#x27;));
        if(symbols.first()){
            return this.symbols.get(symbols.first().get(&#x27;symbol&#x27;));
        }
        else {
            return;
        }
    }

    /**
     * Check if symbol exists and is active
     *
     * @method isSymbolActive
     * @param {String} SYMBOL
     * @return {Bool}     
     */
    isSymbolActive(symbol) {
        return this.symbols.getIn([symbol, &#x27;state&#x27;]) ? 1 : 0;
    }

    /**
     * Returns true if market exists and opened and false if not.
     *
     * @method isMarketOpened
     * @param {String} MARKET
     * @return {Bool}      
     */
    isMarketOpened(market) {
        return this.tree.getIn([market, &#x27;state&#x27;]) ? 1 : 0;
    }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
